#开源书
##开源杂志
一年前，诞生了一份开源期刊，叫《开源杂志》；一年之后，孕育了《开源杂志》问答社区DoAsk；而到了今天，《开源杂志》在线阅览版终于踏浪破冰而来，闪耀登场，并将惊艳四座。
* 免费，也可捐赠。
* 这是一本由一群计算机爱好者开创的杂志，开源这一词最早也是在信息技术行业里兴起的，所以，我们的信息技术工作者，永远走在信息技术的尖端，《开源杂志》这是一本开源的书，当下有很多开源平台，开源软件，开源代码，开源书也将抢占很大一部分市场。尽管现在不是共产主义社会，但我们的开源项目却是本该属于共产主义社会的产物。
##OpenBook
##Git
###Git简介

Git是一款分布式版本控制系统，有别于CVS和SVN等集中式版本控制系统，Git可以让研发团队更加高效的协同工作，从而提高生产率。使用Git，开发人员的工作不会因为频繁地遭遇提交冲突而中断，管理人员也无须为数据的备份而担心。经过Linux这样庞大项目的考验之后，Git被证明可以胜任任何规模的团队，即便团队成员分布于世界各地。
>Git的发音，一般人把它读作“技特”，实际上这里的G应该发[g]的音，而不是[j]这个音。

###版本控制的前世今生
#### CVS开启了版本控制大爆发。
>CVS(Concurrent Versions System)诞生于1985年，是由荷兰阿姆斯特丹VU大学的Dik Grune教授实现的。（http://www.nongnu.org/CVS/）
>
>CVS采用客户端/服务器架构设计，版本库位于服务器端，实际上也就是一个RCS文件容器。每一个RCS文件只保留一个版本的完全拷贝，其他历次更改仅将差异存储其中，使得存储变得非常有效率。
	
>CVS这种实现方式的最大好处就是简单。把版本库中任意一个目录拿出来就可以成为另外一个版本库。如果将版本库中的一个RCS文件冲命名，工作区检出的文件名也会相应地改变。这种低成本的服务器管理模式成为很多CVS粉丝至今不愿离开CVS的原因。
	
>CVS成功地为后来的版本控制系统确立了标准，像提交说明（commit log）、检入（checkin）、检出（checkout）、里程碑（tag）、分支（branch）等概念在CVS中早就已经确立。CVS的命令行格式也被后来的版本控制系统竞相模仿。
	
>CVS版本控制系统示意图
	
>>>>![Alt text ](./image/CVS.jpg)

>CVS的成功导致了版本控制系统的大爆发，各式各样的版本控制系统如雨后春笋般诞生了。新的版本控制系统或多或少地解决了CVS版本控制系统存在的问题。在这些版本控制系统中，最典型的就是Subversion(SVN)。
####SVN—————集中式版本控制集大成者
Subversion(参考：http://subversion.apache.org/),由于其命令行为svn，因此通常被简称为SVN。SVN由CollabNet公司于2000年资助并开始开发，目的是创建一个更好的版本控制系统以取代CVS。SVN的前期开发使用CVS做版本控制，到了2001年，SVN已经可以用于自己的版本控制了。(参考：http://svnbook.red-bean.com/en/1.5/svn.intro.whatis.html#svn.intro.history)

SVN版本控制系统示意图
>>>>![Alt text ](./image/SVN.jpg)

SVN的每一次提交，都会在服务器端的db/revs和db/revprops目录下各创建一个以顺序数字编号命名的文件。其中，db/revs目录下的文件（即变更集文件）记录了与上一个提交之间的差异（字母A表示新增，M表示修改，D表示删除）。在db/revprops目录下的同名文件则保存着提交日志、作者、提交时间等信息。这样设计的好处有：

* 拥有全局版本号。没提交一次SVN的版本号就会自动加1
* 实现了原子提交。SVN不会像CVS那样出现文件的部分内容被提交而其余的内容没有被提交的情况。
* 文件名不受限制。
* 文件和目录重命名也得到了支持。
* SVN还有一个创举，就是在工作区跟踪目录下(.svn目录)为当前目录中的一个文件都保存一份冗余的原始拷贝。这样做的好处是部分命令不再需要网路连接，例如文件修改的差异比较，以及错误更改的退回等。

正是由于这些闪亮的功能特性，才使得SVN在CVS之后诞生的诸多版本控制系统中脱颖而出，成为开源社区一时的新宠，也成为当时各个企业进行版本控制的最佳选择之一。

但是相对于CVS，SVN在本质上并没有突破，都属于集中式版本控制系统。即一个项目只有唯一的一个版本库与之对应，所有的项目成员都通过网络向该服务器进行提交。这样的设计除了容易出现单点故障以外，在查看日志和提交数据等操作时的延迟，会让基于广域网协同工作的团队抓狂。

除了集中式版本控制系统固有的问题外，SVN的里程碑和分支的设计也被证明是一个错误，虽然这个错误的设计使得SVN有了快速创建里程碑和分支的能力，但是这个错误的设计也导致了如下更多的问题。

* 项目文件在版本库中必须按照一定的目录结构进行部署，否则就可能无法建立里程碑和分支。
* 创建里程碑和分支会破坏精心设计的授权。
* 分支太随意从而导致混乱。
* 虽然SVN在1.5版之后拥有了合并追踪功能，但这个功能会因为混乱的分支管理而被抵消。

2009年年底，SVN由CollabNet公司交由Apache社区管理，至此SVN成为了Apache组织的一个子项目（http://en.wikipedia.org/wiki/Apache_Subversion）。这对SVN到底意味着什么？是开发的停滞？还是新的开始？结果如何我们将拭目以待。

###Git————Linus的第二个伟大作品
####Git出现背景
Linux之父Linus是坚定的CVS反对者，它同样地也反对SVN。这就是为什么在1991-2002这是与年之间，Linus宁可手工修补文件的方式维护代码，也迟迟不愿使用CVS的原因。

>2002年至2005年Linus顶着开源社区精英们口诛笔伐的压力，选择了一个商业版本控制系统Bikeeper作为Linux内核的代码管理工具（http://en.wikipedia.org/wiki/BitKeeper）。Bikeeper不同于CVS和SVN等集中式版本控制工具，而是一款分布式版本控制工具。

分布式版本控制系统最大的反传统之处在于，可以不需要集中式的版本库，每个人都工作在通过克隆建立的本地版本库中。也就是说每个人都拥有一个完整的版本库，查看提交日志、提交、创建里程碑和分支、合并分支、回退等所有操作都直接在本地完成而不需要网络连接。每个人都是本地版本库的主人，不再有谁能提交谁不能提交的限制，加上多样的协同工作模型（版本库间推送、拉回，以及补丁文件传送等）让开源项目的参与度有爆发式增长。
####Git的诞生

2005年发生的一件事最终导致了Git的诞生。在2005年4月，Andrew Tridgell（即大名鼎鼎的Samba的作者）视图对BitKeeper进行反向工程，以开发一个能与BitKeeper交互的开源工具。这激怒了BitKeeper软件的所有者BitMover公司，要求收回对Linux社区免费使用BitKeeper的授权（http://en.wikipedia.org/wiki/Andrew_Tridgell）。迫不得已，Linus选择了自己开发一个分布式版本控制工具以替代BitKeeper。以下就是Git诞生过程中的大事记（http://en.wikipedia.org/wiki/Git_%28software%29）：

* 2005年4月3日，开始开发Git.
* 2005年4月6日，项目发布。
* 2005年4月7日，Git就可以作为自身的版本控制工具了。
* 2005年4月18日，发生第一个多分支合并。
* 2005年4月29日，Git的性能就已经达到了Lnus的预期。
* 2005年6月16日，Linux内核2.6.12发布，那时Git已经在维护Linux核心的源代码了。

Linus一个文件系统专家和内核设计者的视角对Git进行了设计，其独特的设计让Git拥有非凡的性能和最为优化的存储能力。完成原型设计后，在2005年7月26日，Linus功成身退，将Git的维护交给另外一个Git的主要贡献者Junio C Hamano（http：//marc.info/?l=git&m=112243466603239），直到现在。
####Git的发展

最初的Git除了一些核心命令以外，其他的都用脚本语言开发，而且每个功能都能作为一条独立的命令，例如克隆操作用git-clone，提交操作用git-commit。这导致Git拥有庞大的命令集，使用习惯也和其他版本控制系统格格不入。随着Git的开发者和使用者的增加，Git也在逐渐演变，例如到1.5.4版本时，将一百多个独立的命令封装为一个git命令，使它看起来更像是一个独立的工具，也使Git更贴近于普通用户的使用习惯。

经过几年的发展，众多的开源项目都纷纷从SVN或其他版本控制系统迁移到Git。虽然版本控制系统的迁移过程是痛苦的，但是因为迁移到Git带来开发效率的极大提升，以及巨大的效益，所以很快就会忘记迁移的痛苦过程，而且很快就会适应新的工作模式。

Git虽然是在Lniux下开发的，但现在已经可以跨平台运行在所有主流的操作系统上，包括Linux、Mac OS X 和Windows等。可以说每一个使用计算机的用户都可以分享Git带来的便利和快乐。
###Git应用

####利用Git做数据的备份：

![Alt text ](./image/Git_copy.jpg) 

写完一个小节或是画完一张图后，应该执行以下命令提交一次。提交时在本地完成的，因此在途中没有表示出来。

```$ git add -u ```   # 如果创建了新的文件，可以执行git add -i命令。

```$ git commit ```
下班的时候应该执行一次推送

```$ git push ```

图中标记为mirror的版本库就是Git镜像版本库，该版本库只向用户提供只读访问服务，而不能对其进行写操作（推送）。

从图中可以看出，我每日的工作都有三个拷贝，一个在笔记本中，一个在公司内网服务器上，还有一个在外网的镜像版本库中。鸡蛋分别装在了三个篮子里。

####利用Git实现异地工作协同

![Alt text ](./image/Git_diff_way.jpg) 

如果在家里要工作的话，首先要做的就是图中步骤③的操作：将mirror版本库中的数据同步到本地。只需要一条命令就好了：

``` $ git pull mirror master ```

然后在家里的电脑上继续工作，并提交。当准备完成一天的工作后，就执行下面的命令，相当于图中步骤④的操作：将在家中的提交推送到标记为home的版本库中。

```$ git push home ```

注：为什么还要再引入一个名为home的版本库呢？使用mirror版本库不好么？不要忘了mirror版本库只是一个镜像库，不能提供写操作。

当一早到公司，开始工作之前，先执行图中步骤⑤的操作，从home版本库将家里做的提交同步到公司的电脑中。

```$ git pull home master```

公司里的其他同事想看我的工作成果的话，可以执行图中步骤⑥操作：

```$ git pull```

一旦该同事发现我提交的内容有错误，他可以进行修改，然后推送到公司的服务器上（图中步骤⑦）。当然他的这个推送也会自动同步到外网的mirror版本库。

```$ git push```

而这个时候，我只要执行git pll操作就可以获取他对我内容的修订（步骤⑧）。 所以我的文档就一共有了6个拷贝。

####现场版本控制

* （1）创建现场版本库。直接在需要版本控制的目录下执行Git版本库初始化命令。

	```$ git init```

* （2）添加文件并提交。

	```$ git add -A```

	```$ git commit -m "initialized"```

* （3）为初始提交建立一个里程碑：“v1”。

	```$ git tag v1```

* （4）开始在工作区中工作————修改文件并提交。

	```$ git commit -a```

* （5）当对工作成果满意并想将工作成果保存带走时，可以通过下面的命令将从v1开始的历次提交逐一导出为补丁文件。转换的补丁文件都包含一个数字前缀，并提取提交日志信息作为文件名，而且补丁文件还提供对二进制文件的支持。

	```$ git format-patch v1..HEAD```

* （6）通过邮件将补丁文件发出。当然，也可以通过其他方式将补丁带走。

	```$ git send-email *.patch```

####避免引入辅助目录
* SVN和CVS都要在工作区的每一个子目录下创建,svn或是CVS目录。这些辅助目录如果出现在服务器上，尤其是web服务器上是非常危险的，因为这些辅助目录下的Entries文件会暴露出目录下的文件列表，让管理员精心配置的禁止目录浏览的努力全部白费。

* .svn辅助目录下还存在文件的原始拷贝，在文件搜索时结果会加倍。Git没有这个问题，不会在子目录下引入讨厌的辅助目录或文件（.gitignore和.gitattributes文件不算）。

* Git还专门提供了一个git grep命令，这样在工作区根目录下执行查找时，目录.git也不会对搜索造成影响。

####重写提交说明

Git修改提交说明很简单，而且提交说明的修改也是被追踪的。Git修改最新提交的说明最为简单，使用一条名为修补提交的命令即可。

```$ git commit --amend```

如果要修改某个历史提交的提交说明，Git也可以实现，但要用到另外一个命令：变基命令。例如要修改<commit-id>所标识的提交的提交说明，执行下面的命令，并在弹出的变基索引文件中修改相应提交前面的动作的关键字。

```$ git rebase -i <commit-id>```

####想吃后悔药
假如提交的数据中不小心包含了一个不应该检入的虚拟机文件————大约有1个GB！这时候，您会多么希望这个世界上有后悔药卖啊。如果你用Git，一切就会变得非常简单，而且你也不必去乞求管理员，因为使用Git，每个人都是管理员。

如果是最新的提交引入了不该提交的大文件：winxp.img，操作起来会非常简单，还是用修补提交命令。

```$ git rm --cached winxp.img```

```$ git commit --amend```

如果是历史版本，例如在<commit-id>所标识的提交中引入的文件，则需要使用变基操作。

```$ gut rebase -i <commit-id>^```

####工作进度保存

如果在工作区的修改尚未完成时忽然有一个紧急的任务需要从一个干净的工作区开始新的工作，或要切换到别的分支进行工作，那么如何保存当前尚未完成的工作进度呢？
#####Git的解决方案

Git提供了一个可以保存和恢复工作进度的命令git stash。这个命令非常方便地解决了这个难题。

在切换到新的分之前执行git stash保存工作进度，工作区就会变得非常干净，然后就可以切换到新的分支中了。

```$ git stash```

```$ git checkout <new_branch>```

新的工作分支修改完毕后，再切换回当前分支，调用git stash pop命令则可恢复之前保存的工作进度。

```$ git checkout<orignal_branch>```

```$ git stash pop```

####代理SVN提交实现移动式办公

使用像SVN一样的集中式版本控制系统，要求使用者和版本控制服务器之间要有网络连接，如果因为出差在外或在家办公访问不到版本控制服务器就无法提交。Git属于分布式版本控制系统，不存在这样的问题。

>当版本控制武大实现现场从SVN到Git的迁移时，仍然可以使用Git进行工作。在这种情况下，Git作为客户端来操作SVN服务器，实现在移动办公状态下的版本提交（当然是在本地Git库中提交）。当能够连通SVN服务器时，一次性将移动办公状态下的本地提交同步到SVN服务器。整个过程对于SVN来说是透明的，没有人知道你是使用Git在进行提交。

* 使用Git来操作SVN版本控制服务器的一般工作流程为：
	* (1)访问SVN服务器，将SVN版本库克隆为一个本地的Git库，一个货真价实的Git库，不过其中包含针对SVN的扩展。
	
		```$ git svn clone <svn_repos_url>```
	* (2)使用Git命令操作本地克隆的版本库，例如提交就使用git commit命令。
	* (3)当能够通过网络连接到SVN服务器，并将本地提交同步到SVN服务器时，先获取SVN服务器上最新的提交，然后执行变基操作，最后再将本地提交推送给SVN服务器。

		```$ git svn fetch```

		```$ git svn rebase```

		```$ git svn dcommit```
###Git的基础操作
####留影
在Git里“留影”用的命令叫做tag，更加专业的术语叫做“里程碑”（打tag，或打标签）。“留影”操作如下：

```$ cd/path/to/my/workspace/demo```

```$ git tag -m "say bye-bye to all previous practice."old_practice```

```$ ls .git/refs/tags/old_practice```

```$ git rev-parse refs/tags/old_practice```

留影过后可以执行```git describe```命令将最新提交显示为一个易记的名称。显示的时候回选取离该提交最近的里程碑作为“基础版本号”

####删除文件
看看版本库当前的状态，暂存区和工作区都包含修改。

```$ git status -s```

* 保存进度。
	
```$ git stash```

* 再恢复进度。因为这个保存的进度要被多次用到，所以这里不用git stash pop
	
```$ git stash apply```
#####本地删除不是真正的删除
看当前工区的文件有：

```$ ls```

直接在工作区删除这些文件（若这些文件都是些.txt文件）

```$ rm *.txt```

通过以下命令，可以看到在暂存区（版本库）中的文件仍然存在，并未删除。

```$ git ls-files```

所以，文件只是在本地进行了删除，尚未添加到暂存区（提交任务）中。也就是说：直接在工作区删除，对暂存区和版本库没有任何影响。

#####执行git rm命令删除文件

在本地删除之后，执行git status可以看到删除的文件是列出来的，我们可以将他们（假设为1.txt、2.txt、3.txt)全部删除，执行以下命令：

```$ git rm 1.txt 2.txt 3.txt```

这个时候删除动作已经加入了暂存区，这时需要提交动作，就是真正意义上的文件删除了。

```$ git commit -m "delete trash files.(using:git rm)"```

删除之后不用担心，因为文件只是在版本库的最新提交中被删除了，在历史提交中尚在。可以通过下面的命令查看历史版本中尚在的删除文件列表。

```$ git ls-files --with-tree=HEAD^```

```$ git cat-files -p HEAD^:1.txt```
#####命令git add -u快速标记删除


 在前面执行git rm命令时，写下了所有要删除的文件名，这条命令很长，实际上git add就可以，即使用-u参数调用git add命令，含义是将本地有改动的文件标记到暂存区。为了重现刚才的场景，先使用重置命令抛弃最新的提交，再使用进度恢复到之前的状态，具体操作如下。

(1)丢弃之前测试删除的实验性提交。

```$ git reset --hard HEA^```

(2)恢复保存的进度

```$ git stash apply -q```

(3)然后删除本地文件，状态显示出依然只是在本地删除了文件，暂存区中的文件仍在。

```$ rm *.txt```

```$ git status -s```

(4)执行git add -u命令可以将（被版本库追踪的）本地文件的变更（修改、删除）全部记录到暂存区中。

```$ git add -u```

(5)查看状态，可以看到工作区删除的文件全部被标记为下次提交时删除。

```$ git status -s```

(6)执行提交，删除文件。

```$ git commit -m "delete trash files.(using:git add -u)"```

####恢复删除的文件
删除了文件之后，现在我们需要恢复删除掉的某个文件1.txt。由于我们删除的只是最新一次提交的文件，所以历史提交中的文件仍然保留，可以从历史提交中提取文件。

```$ git cat-file -p HEAD~1:1.txt > 1.txt```

这里也可以用git show来取代git cat-file -p命令，效果相同。

```$ git show HEAD~1:1.txt > 1.txt```

使用git checkout命令则为最简洁实用。

```$ git checkout HEAD~1 -- 1.txt```

注：这里的HEAD^与HEAD~1都指的是HEAD的上一次提交。

下面是将恢复过来的1.txt文件添加回暂存区。

```$ git add -A```

```$ git status -s```

```$ git commit -m "restore file:1.txt"```

####移动文件
通过将1.txt改名为README文件来测试一下在Git中如何移动文件。Git提供了git mv命令来完成改名操作。

```$ git mv 1.txt README```

可以从当前状态中看到改名的操作。

```$ git status```

提交改名操作。

```$ git commit -m "改名测试"```

所谓的改名就是对旧文件的删除，和对新文件的添加，所以可以用删除和添加来操作。

* 撤销之前测试文件移动的提交。

```$ git reset --hard HEAD^```

* 撤销之后1.txt文件又回来了。

```$ git status -s```

```$ git ls-file```

新的改名操作不使用git mv命令，而是直接在本地改名（文件移动），将1.txt改名为README。

```$ mv 1.txt README```

```$ git status -s```

为了考验一下Git的内容追踪能力，再修改一下改名后的README文件，即在文件末尾追加一行。

```$ echo "Bye-Bye." >> README```

可以使用前面介绍的git add -A命令。相当于对修改文件执行git add，对删除文件执行git rm，对本地新增文件执行git add。

```$ git add -A```

查看状态，也可以看到文件重命名。

```$ git status```

执行提交。

```$ git commit -m "README is from 1.txt."```

此次的重命名相似度将不再是100%。
